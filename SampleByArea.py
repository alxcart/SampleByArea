# -*- coding: utf-8 -*-
"""
/***************************************************************************
 SampleByArea
                                 A QGIS plugin
This plugin elaborates the area-oriented sampling plan. It is based on the ISO 19157 and ISO 2859 series of standards. 
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2019-05-08
        git sha              : $Format:%H$
        copyright            : (C) 2019 by Alex Santos
        email                : alxcart@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
#from qgis.core import QgsProject, Qgis

from PyQt5.QtCore import QSettings, QTranslator, qVersion, QCoreApplication
from PyQt5.QtGui import QIcon
from PyQt5.QtWidgets import QAction, QFileDialog, QMessageBox

from qgis.core import *
from math import ceil
import os.path
from osgeo import ogr
import random

from .constants import * # constants of project

# baseado no plugin clip_multiple_layers (raster e vetor)
import processing, os, subprocess, time
from qgis.utils import *
from qgis.core import *
#from qgis.gui import QgsMessageBar
# from qgis.PyQt.QtGui import QProgressBar
from qgis.PyQt.QtCore import *

from processing.algs.gdal.GdalUtils import GdalUtils

# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .SampleByArea_dialog import SampleByAreaDialog
##import os.path

def truncate(f, n):
#Truncates/pads a float f to n decimal places without rounding
    s = '{}'.format(f)
    if 'e' in s or 'E' in s:
        return '{0:.{1}f}'.format(f, n)
    i, p, d = s.partition('.')
    return '.'.join([i, (d+'0'*n)[:n]])

def size_of_grid(size, units_id):
#Convert km to layer units measurement / converte a distance em km para a unidade de medida do layer
    d=QgsDistanceArea()
    grid_size = 0.0 # Initial value of cell size / valor inicial do grid em km
    try: 
        size = float(size)
    except ValueError:
        QMessageBox.critical(None, "Size of inspection area", "Please enter a numerical value")
    if type(size) is not str:
        distance = abs(size)
        k = d.convertLengthMeasurement(1, uKilometers)
        #grid_size = 1.0000
        if units_id==uUnknownDistanceUnit:
            QMessageBox.critical(None, "Alert", "Layer with unknown unit of measure") 
        if units_id!=uUnknownDistanceUnit:
            grid_size = truncate(float(d.convertLengthMeasurement(distance/k, units_id)), 4)            
    return grid_size 
    

class SampleByArea:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        #units =""
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'SampleByArea_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)

            if qVersion() > '4.3.3':
                QCoreApplication.installTranslator(self.translator)
        
        # Create the dialog (after translation) and keep reference
        self.dlg = SampleByAreaDialog()
        
        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&Sample by area')

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        #self.first_start = None
        
        #Conectando os botoes e acoes
        self.dlg.lineEdit.clear()
        self.dlg.label_units.clear()
                
        self.initFolder();
        self.dlg.pushButton.clicked.connect(self.select_output_file);

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        # Usar para a traducao de mensagens
        return QCoreApplication.translate('SampleByArea', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToVectorMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/SampleByArea/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'Sample by area'),
            callback=self.run,
            parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = True


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginVectorMenu(
                self.tr(u'&Sample by area'),
                action)
            self.iface.removeToolBarIcon(action)

    def initFolder(self):
        path_project = QgsProject.instance().fileName()
        path_project = path_project[:path_project.rfind("/"):]

        self.folderName = path_project

        self.dlg.lineEdit.setText(self.folderName);

    def select_output_file(self):
    #Seleciona folder de saida
        folderTmp = QFileDialog.getExistingDirectory(self.dlg, "Select output folder ", self.folderName)
        if folderTmp != "":
            self.folderName = folderTmp
        self.dlg.lineEdit.setText(self.folderName);

    def isFileOpened(self, file_path):
        if os.path.exists(file_path):
            try:
                os.rename(file_path, file_path+"_")
                os.rename(file_path+"_", file_path)
                return False
            except OSError as e:
                return True
    
    def return_units(self):
    #Retorna a unidade de medida da camada
    #Input data selection
        index = self.dlg.comboBox.currentIndex()
        selection = self.dlg.comboBox.itemData(index)
        # Executa apenas se houver uma seleção no comboBox
        if selection is not None:
            units = QgsUnitTypes.toString(selection.dataProvider().crs().mapUnits())
            units_id = (selection.dataProvider().crs().mapUnits())
            self.dlg.label_units.setText(units)
            size = self.dlg.lineEditSize.text()
            # Function size of grid
            grid = size_of_grid(size, units_id)
            self.dlg.label_size.setText(str(grid))
            return units, units_id, grid
  
    def run(self):
        """Run method that performs all the real work"""
        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.first_start == True:
            self.first_start = False
            self.dlg = SampleByAreaDialog()
            self.dlg.pushButton.clicked.connect(self.select_output_file)
            self.dlg.comboBox.currentIndexChanged.connect(self.return_units)
            self.dlg.lineEditSize.textChanged.connect(self.return_units)

        # Preenchendo o comboBox (principal)
        self.dlg.comboBox.clear()
        self.dlg.lineEditSize.setText(str(10.0))

        layers = QgsProject.instance().mapLayers().values()
        for layer in layers:
            if layer.type() == QgsMapLayer.VectorLayer :
                self.dlg.comboBox.addItem( layer.name(), layer )
        #self.dlg.label_units.addItem(layer.encoding)
        ## Fetch the currently loaded layers
        #layers = QgsProject.instance().layerTreeRoot().children()
        
        ## Clear the contents of the comboBox from previous runs
        #self.dlg.comboBox.clear()

        ## Populate the comboBox with names of all the loaded layers
        #self.dlg.comboBox.addItems([layer.name() for layer in layers])

        # show the dialog
        self.dlg.show()
        # Run the dialog event loop
        result = self.dlg.exec_()

        # See if OK was pressed
        if result:
            # Do something useful here - delete the line containing pass and
            # substitute with your code.
            #filename = self.dlg.lineEdit.text()

            if not os.path.isdir(self.folderName):
                raise FileNotFoundError(
                    errno.ENOENT, os.strerror(errno.ENOENT), self.folderName)

            directory = self.folderName + "/sample"
            if not os.path.exists(directory):
                os.makedirs(directory)

            #ly = iface.activeLayer()
            #ly.name()
            #selection = ly
            #dp = ly.dataProvider()
            #lyrInput = selection
            #Nivel_de_Inspecao = 1

            #Preparar saida
            #path_project = QgsProject.instance().fileName()
            #path_project = path_project[:path_project.rfind("/"):]
            #directory = path_project + "/amostras"
            pth = directory
            gpkg = os.path.join(pth + "/sample_area.shp")
            filename = gpkg


            #Input data selection 
            index = self.dlg.comboBox.currentIndex()
            selection = self.dlg.comboBox.itemData(index)
            checkedLayers = QgsProject.instance().layerTreeRoot().checkedLayers()
            size = self.dlg.lineEditSize.text()            

            # Data provider from selection 
            dp = selection.dataProvider()
            #geometry = selection.wkbType()
            geometry = 6 #'MultiPolygon' 
            crs = dp.crs()
            encoding = dp.encoding()
            units = (QgsUnitTypes.toString(crs.mapUnits()))
            units_id = (selection.dataProvider().crs().mapUnits())
            #grid_size = size_of_grid(size, units_id)
            #self.dlg.label_units.setText(units)

            #Data source
            ds = ogr.GetDriverByName("Esri Shapefile")
            
            # Function size of grid
            grid = size_of_grid(size, units_id)
            grid_size = float(grid)

            # Data features from selection 
            lyrInput = selection
            #lyrInput = QgsVectorLayer.getFeatures(selection) # substituir camada por selection OK
            #layer = lyrInput #substituir lyrInput por "features" 
            #features = vector.features(layer)                                    ## area temp layer
            #features = QgsVectorLayer.getFeatures(selection)
            #featureCount = len(selection) # substituir camada por selection - OK ## area temp layer
            
            fields = QgsFields() # utilizar na inspecao por area 
            #fields = dp.fields()
            fields.append(QgsField("id_measure", QVariant.Int))
            fields.append(QgsField("checked", QVariant.String))
            fields.append(QgsField("status", QVariant.String))

            #Temporary layer
            file = QgsVectorFileWriter(filename, encoding, fields, geometry, crs, ds.name)
            lyrIntermediate=QgsVectorLayer("Polygon"+"?crs="+str(crs.authid()),"temporary_polygons","memory")
            lyrIntermediate.setCrs(lyrInput.crs())

            # Sampling plans # Plano de amostragem
            Nivel_de_Inspecao = self.dlg.comboBoxLevel.currentIndex()
            #CONSTANTE (plano de amostragem)
            #dicSampleLength={2:[2,2,3],9:[2,3,5],16:[3,5,8],26:[5,8,13],51:[5,13,20],91:[8,20,32],151:[13,32,50],281:[20,50,80],501:[32,80,125],1201:[50,125,200],3201:[80,200,315],10001:[125,315,500],35001:[200,500,800],150001:[315,800,1250],500001:[500,1250,2000]}
            
            #Function Grid
            xmin,ymin,xmax,ymax = lyrInput.extent().toRectF().getCoords()
            gridWidth = grid_size #Size of cell grid / Tamanho da celula da grade
            gridHeight = grid_size #Size of cell grid / Tamanho da celula da grade
            
            rows = ceil((ymax-ymin)/gridHeight)
            cols = ceil((xmax-xmin)/gridWidth)
            ringXleftOrigin = xmin
            ringXrightOrigin = xmin + gridWidth
            ringYtopOrigin = ymax
            ringYbottomOrigin = ymax-gridHeight
            #fields = [ QgsCore.QgsField("id", QtCore.QVariant.Int ) ]

            id=1
            for i in range(int(cols)):
                ringYtop = ringYtopOrigin
                ringYbottom =ringYbottomOrigin
                for j in range(int(rows)):
                    points = [QgsPointXY(ringXleftOrigin, ringYtop),QgsPointXY(ringXrightOrigin, ringYtop),QgsPointXY(ringXrightOrigin, ringYbottom), QgsPointXY(ringXleftOrigin, ringYbottom), QgsPointXY(ringXleftOrigin, ringYtop)] 
                    request = QgsFeatureRequest(QgsRectangle(ringXleftOrigin,ringYtop,ringXrightOrigin,ringYbottom))
                    for feature in  lyrInput.getFeatures(request):
                        square = QgsFeature()
                        square.setGeometry(QgsGeometry.fromPolygonXY([points]))
                        square.setAttributes([id])
                        perc = id / (cols * rows * 100)
                        #progress.setPercentage(perc)
                        lyrIntermediate.dataProvider().addFeatures([square])
                        lyrIntermediate.updateExtents()
                        id = id + 1
                        break
                    ringYtop = ringYtop - gridHeight
                    ringYbottom = ringYbottom - gridHeight
                ringXleftOrigin = ringXleftOrigin + gridWidth
                ringXrightOrigin = ringXrightOrigin + gridWidth

            # Sample size # Tamanho da amostra 
            layer = lyrIntermediate
            layer.setCrs(lyrInput.crs())
            features = QgsVectorLayer.getFeatures(lyrIntermediate)
            #features = vector.features(layer)
            featureCount = len(lyrIntermediate)
            
            # Function select sample # Seleciona amostra
            #Input: featureCount (area ou feicoes)
            #Output: tamanho da amostra (sample_size)
            for i in sorted(dicSampleLength.keys(),reverse=True):
                if featureCount >= i:
                    index1 = i
                    break

            randomNum = random.sample(range(featureCount),1)[0]
            sample_size=dicSampleLength[index1][Nivel_de_Inspecao]

            #isSelectedId = random.sample(range(featureCount), sample_size)

            #Fim Function seleciona amostra
            
            #Systematic sampling #Amostragem sistematica
            step= lyrIntermediate.featureCount() // dicSampleLength[index1][Nivel_de_Inspecao]
            module = randomNum % step
            #progress.setInfo("Numero aleatorio: " + str(randomNum))
            #progress.setInfo( 'Amostra: ' + str(dicSampleLength[index1][Nivel_de_Inspecao]))
            #progress.setInfo( 'Passo: ' + str(step))
            #progress.setInfo( 'Sorteado: ' + str(randomNum))

            # Selecting Sample Cells / Selecionando celulas da amostra
            #progress.setInfo('Selecionando celulas da amostra...')
            listIds=range(featureCount) 
            isSelectedId = []
            x = 1
            for i in listIds:
                if x <= sample_size: 
                    if (i) % step == module:
                        isSelectedId.append(i)
                        x += 1    
          

            for i, feat in enumerate(features):
                if i in isSelectedId:
                    file.addFeature(feat)

            del file

            layer = QgsVectorLayer(filename, filename.split("/")[-1]+str(sample_size), "ogr")
            #layer = QgsVectorLayer(filename, filename.split("/")[-1], "ogr")
            #layer.setValid(True)
            #QgsProject.instance().addMapLayer(layer)
            
            iface.addVectorLayer(filename, "", "ogr")
            #iface.addVectorLayer(filename, filename.split("/")[-1], "ogr")
            #iface.addVectorLayer(memoria, "", "memory")
            #out = iface.addVectorLayer(lyrOutput, "", "ogr")

            #progress.setInfo('Number of samples selected:  ' + str(len(isSelectedId)))
            #progress.setInfo('Alex Santos and Viviane Diniz')

            QMessageBox.about(None, "Systematic random sampling", "Sampling units created")

